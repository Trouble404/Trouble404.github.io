<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[(Logbook) -- Object Detection System Based on CNN and Capsule Network]]></title>
    <url>%2F2018%2F05%2F25%2FLogBook%2F</url>
    <content type="text"><![CDATA[Gantt chart Check list 1) preparation 1.1) Familiarization with develop tools 1.1.1) Keras 1.1.2) Pythrch 1.2) Presentation 1.2.1) Poster conference 2) Create image database 2.1) Confirmation of detected objects 2.2) Collect and generate the dataset 3) Familiarization with CNN based object detection methods 3.1) R-CNN 3.2) SPP-net 3.3) Fast R-CNN 3.4) Faster R-CNN 4) Implement object detection system based on one chosen CNN method 4.1) Pre-processing of images 4.2) Extracting features 4.3) Mode architecture 4.4) Train model and optimization 4.5) Models ensemble 5) Implement object detection system based on Capsule network 5.1) Investigate and familiarisation with the principle of Capsule network. 5.2) Building and testing mode 6) Analysis work 6.1) Evaluation of detection result of two methods. 6.2) Analyse the difference between two methods. 7) Paperwork and bench inspection 7.1) Logbook 7.2) Write the thesis 7.3) Project video 7.4) Speech and ppt of bench inspection 8) Documents 8.1) Project Brief May28/05/2018Keras is a high-level neural networks API, written in Python and capable of running on top of TensorFlow, CNTK, or Theano. Keras document Keras 文档 Installation TensorFlowMicrosoft Visual Studio 2015CUDA 9.0cuDNN7Anaconda Step 1: Install VS2015 Step 2: Install CUDA 9.0 并添加环境变量 Step 3: Install cuDNN7 解压后把cudnn目录下的bin目录加到PATH环境变量里 Step 4: Install Anaconda 把安装路径添加到PATH里去, 在这里我用了 Python 3.5 Step 5: 使用Anaconda的命令行 新建一个虚拟环境,激活并且关联到jupyterbook123conda create --name tensorflow python=3.5activate tensorflowconda install nb_conda Step 6: Install GPU version TensorFlow.1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple --ignore-installed --upgrade tensorflow-gpu Keras Step 1: 启动之前的 虚拟环境， 并且安装Keras GPU 版本12activate tensorflowpip install --upgrade tensorflow-gpu 在硕士学习过程中，使用Keras的项目** NBA with Machine Learning Kaggle- Job salary prediction TensorFlow CPU 切换1234567891011import tensorflow as tf import osimport keras.backend.tensorflow_backend as KTF os.environ["CUDA_VISIBLE_DEVICES"] = "0" #设置需要使用的GPU的编号config = tf.ConfigProto()config.gpu_options.per_process_gpu_memory_fraction = 0.4 #设置使用GPU容量占GPU总容量的比例sess = tf.Session(config=config)KTF.set_session(sess)with tf.device('/cpu:0'): 这样可以在GPU版本的虚拟环境里面使用CPU计算 Jupyter Notebook 工作目录设置启动命令行，切换至预设的工作目录， 运行：1jupyter notebook --generate-config June01/06/2018PyTorch is a python package that provides two high-level features: Tensor computation (like numpy) with strong GPU acceleration Deep Neural Networks built on a tape-based autodiff system Package Description torch a Tensor library like NumPy, with strong GPU support torch.autograd a tape based automatic differentiation library that supports all differentiable Tensor operations in torch torch.nn a neural networks library deeply integrated with autograd designed for maximum flexibility torch.optim an optimization package to be used with torch.nn with standard optimization methods such as SGD, RMSProp, LBFGS, Adam etc. torch.multiprocessing python multiprocessing, but with magical memory sharing of torch Tensors across processes. Useful for data loading and hogwild training. torch.utils DataLoader, Trainer and other utility functions for convenience torch.legacy(.nn/.optim) legacy code that has been ported over from torch for backward compatibility reasons Installation Step 1: 使用Anaconda的命令行 新建一个虚拟环境,激活并且关联到jupyterbook123conda create --name pytorch python=3.5activate pytorchconda install nb_conda Step 2: Install GPU version PyTorch.12conda install pytorch cuda90 -c pytorch pip install torchvision Understanding of PyTorch TensorsTensors和numpy中的ndarrays较为相似, 与此同时Tensor也能够使用GPU来加速运算 123456789101112131415161718192021222324from __future__ import print_functionimport torchx = torch.Tensor(5, 3) # 构造一个未初始化的5*3的矩阵x = torch.rand(5, 3) # 构造一个随机初始化的矩阵x # 此处在notebook中输出x的值来查看具体的x内容x.size()#NOTE: torch.Size 事实上是一个tuple, 所以其支持相关的操作*y = torch.rand(5, 3)#此处 将两个同形矩阵相加有两种语法结构x + y # 语法一torch.add(x, y) # 语法二# 另外输出tensor也有两种写法result = torch.Tensor(5, 3) # 语法一torch.add(x, y, out=result) # 语法二y.add_(x) # 将y与x相加# 特别注明：任何可以改变tensor内容的操作都会在方法名后加一个下划线'_'# 例如：x.copy_(y), x.t_(), 这俩都会改变x的值。#另外python中的切片操作也是资次的。x[:,1] #这一操作会输出x矩阵的第二列的所有值 Numpy桥将Torch的Tensor和numpy的array相互转换简，注意Torch的Tensor和numpy的array会共享他们的存储空间，修改一个会导致另外的一个也被修改。 1234567891011121314151617181920212223# 此处演示tensor和numpy数据结构的相互转换a = torch.ones(5)b = a.numpy()# 此处演示当修改numpy数组之后,与之相关联的tensor也会相应的被修改a.add_(1)print(a)print(b)# 将numpy的Array转换为torch的Tensorimport numpy as npa = np.ones(5)b = torch.from_numpy(a)np.add(a, 1, out=a)print(a)print(b)# 另外除了CharTensor之外，所有的tensor都可以在CPU运算和GPU预算之间相互转换# 使用CUDA函数来将Tensor移动到GPU上# 当CUDA可用时会进行GPU的运算if torch.cuda.is_available(): x = x.cuda() y = y.cuda() 使用PyTorch设计一个CIFAR10数据集的分类模型code MMdnnMMdnn is a set of tools to help users inter-operate among different deep learning frameworks. E.g. model conversion and visualization. Convert models between Caffe, Keras, MXNet, Tensorflow, CNTK, PyTorch Onnx and CoreML. MMdnn主要有以下特征： 模型文件转换器，不同的框架间转换DNN模型 模型代码片段生成器，生成适合不同框架的代码 模型可视化，DNN网络结构和框架参数可视化 模型兼容性测试（正在进行中） Github 04/06/2018Dataset: VOC 2012 Dataset Introduce: Visual Object Classes Challenge 2012 (VOC2012)PASCAL‘s full name is Pattern Analysis, Statistical Modelling and Computational Learning.VOC’s full name is Visual OBject Classes.The first competition was held in 2005 and terminated in 2012. I will use the last updated dataset which is VOC2012 dataset. The main aim of this competition is object detection, there are 20 classes objects in the dataset: person bird, cat, cow, dog, horse, sheep aeroplane, bicycle, boat, bus, car, motorbike, train bottle, chair, dining table, potted plant, sofa, tv/monitor Detection TaskReferenced:The PASCAL Visual Object Classes Challenge 2012 (VOC2012) Development KitMark Everingham - John Winnhttp://host.robots.ox.ac.uk/pascal/VOC/voc2012/htmldoc/index.html Task:For each of the twenty classes predict the bounding boxes of each object of that class in a test image (if any). Each bounding box should be output with an associated real-valued confidence of the detection so that a precision/recall curve can be drawn. Participants may choose to tackle all, or any subset of object classes, for example ‘cars only’ or ‘motorbikes and cars’. Competitions:Two competitions are defined according to the choice of training data: taken from the $VOC_{trainval}$ data provided. from any source excluding the $VOC_{test}$ data provided. Submission of Results:A separate text file of results should be generated for each competition and each class e.g. `car’. Each line should be a detection output by the detector in the following format: 1&lt;image identifier&gt; &lt;confidence&gt; &lt;left&gt; &lt;top&gt; &lt;right&gt; &lt;bottom&gt; where (left,top)-(right,bottom) defines the bounding box of the detected object. The top-left pixel in the image has coordinates $(1,1)$. Greater confidence values signify greater confidence that the detection is correct. An example file excerpt is shown below. Note that for the image 2009_000032, multiple objects are detected:1234567comp3_det_test_car.txt: ... 2009_000026 0.949297 172.000000 233.000000 191.000000 248.000000 2009_000032 0.013737 1.000000 147.000000 114.000000 242.000000 2009_000032 0.013737 1.000000 134.000000 94.000000 168.000000 2009_000035 0.063948 455.000000 229.000000 491.000000 243.000000 ... Evaluation:The detection task will be judged by the precision/recall curve. The principal quantitative measure used will be the average precision (AP). Detections are considered true or false positives based on the area of overlap with ground truth bounding boxes. To be considered a correct detection, the area of overlap $a_o$ between the predicted bounding box $B_p$ and ground truth bounding box $B_{gt}$ must exceed $50\%$ by the formula: $a_o = \frac{area(B_p \cap B_{gt})}{area(B_p \cup B_{gt})}$ XML标注格式 对于目标检测来说，每一张图片对应一个xml格式的标注文件。所以你会猜到，就像gemfield准备的训练集有8万张照片一样，在存放xml文件的目录里，这里也将会有8万个xml文件。下面是其中一个xml文件的示例： 123456789101112131415161718192021222324252627282930313233 &lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;annotation&gt; &lt;folder&gt;VOC2007&lt;/folder&gt; &lt;filename&gt;test100.mp4_3380.jpeg&lt;/filename&gt; &lt;size&gt; &lt;width&gt;1280&lt;/width&gt; &lt;height&gt;720&lt;/height&gt; &lt;depth&gt;3&lt;/depth&gt; &lt;/size&gt; &lt;object&gt; &lt;name&gt;gemfield&lt;/name&gt; &lt;bndbox&gt; &lt;xmin&gt;549&lt;/xmin&gt; &lt;xmax&gt;715&lt;/xmax&gt; &lt;ymin&gt;257&lt;/ymin&gt; &lt;ymax&gt;289&lt;/ymax&gt; &lt;/bndbox&gt; &lt;truncated&gt;0&lt;/truncated&gt; &lt;difficult&gt;0&lt;/difficult&gt; &lt;/object&gt; &lt;object&gt; &lt;name&gt;civilnet&lt;/name&gt; &lt;bndbox&gt; &lt;xmin&gt;842&lt;/xmin&gt; &lt;xmax&gt;1009&lt;/xmax&gt; &lt;ymin&gt;138&lt;/ymin&gt; &lt;ymax&gt;171&lt;/ymax&gt; &lt;/bndbox&gt; &lt;truncated&gt;0&lt;/truncated&gt; &lt;difficult&gt;0&lt;/difficult&gt; &lt;/object&gt; &lt;segmented&gt;0&lt;/segmented&gt;&lt;/annotation&gt; 在这个测试图片上，我们标注了2个object，一个是gemfield，另一个是civilnet。 在这个xml例子中： bndbox是一个轴对齐的矩形，它框住的是目标在照片中的可见部分； truncated表明这个目标因为各种原因没有被框完整（被截断了），比如说一辆车有一部分在画面外； occluded是说一个目标的重要部分被遮挡了（不管是被背景的什么东西，还是被另一个待检测目标遮挡）； difficult表明这个待检测目标很难识别，有可能是虽然视觉上很清楚，但是没有上下文的话还是很难确认它属于哪个分类；标为difficult的目标在测试成绩的评估中一般会被忽略。 注意：在一个&lt;object/&gt;中，&lt;name/&gt; 标签要放在前面，否则的话，目标检测的一个重要工程实现SSD会出现解析数据集错误（另一个重要工程实现py-faster-rcnn则不会）。 07/06/2018Poster conference 5 People in one group to present their object.I present this object to my supervisor in this conference. 11/06/2018R-CNNPaper: Rich feature hierarchies for accurate object detection and semantic segmentation 【论文主要特点】（相对传统方法的改进） 速度： 经典的目标检测算法使用滑动窗法依次判断所有可能的区域。本文则(采用Selective Search方法)预先提取一系列较可能是物体的候选区域，之后仅在这些候选区域上(采用CNN)提取特征，进行判断。 训练集： 经典的目标检测算法在区域中提取人工设定的特征。本文则采用深度网络进行特征提取。使用两个数据库： 一个较大的识别库 （ImageNet ILSVC 2012）：标定每张图片中物体的类别。一千万图像，1000类。 一个较小的检测库（PASCAL VOC 2007）：标定每张 图片中，物体的类别和位置，一万图像，20类。 本文使用识别库进行预训练得到CNN（有监督预训练），而后用检测库调优参数，最后在 检测库上评测。 【流程】 候选区域生成： 一张图像生成1K~2K个候选区域 （采用Selective Search 方法） 特征提取： 对每个候选区域，使用深度卷积网络提取特征 （CNN） 类别判断： 特征送入每一类的SVM 分类器，判别是否属于该类 位置精修： 使用回归器精细修正候选框位置 【Selective Search】 使用一种过分割手段，将图像分割成小区域 (1k~2k 个) 查看现有小区域，按照合并规则合并可能性最高的相邻两个区域。重复直到整张图像合并成一个区域位置 输出所有曾经存在过的区域，所谓候选区域其中合并规则如下： 优先合并以下四种区域： 颜色（颜色直方图）相近的 纹理（梯度直方图）相近的 合并后总面积小的： 保证合并操作的尺度较为均匀，避免一个大区域陆续“吃掉”其他小区域 （例：设有区域a-b-c-d-e-f-g-h。较好的合并方式是：ab-cd-ef-gh -&gt; abcd-efgh -&gt; abcdefgh。 不好的合并方法是：ab-c-d-e-f-g-h -&gt;abcd-e-f-g-h -&gt;abcdef-gh -&gt; abcdefgh） 合并后，总面积在其BBOX中所占比例大的： 保证合并后形状规则。 12/06/2018SPP-CNNPaper: Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition 【论文主要特点】（相对传统方法的改进） RCNN使用CNN作为特征提取器，首次使得目标检测跨入深度学习的阶段。但是RCNN对于每一个区域候选都需要首先将图片放缩到固定的尺寸（224*224），然后为每个区域候选提取CNN特征。容易看出这里面存在的一些性能瓶颈： 速度瓶颈：重复为每个region proposal提取特征是极其费时的，Selective Search对于每幅图片产生2K左右个region proposal，也就是意味着一幅图片需要经过2K次的完整的CNN计算得到最终的结果。 性能瓶颈：对于所有的region proposal防缩到固定的尺寸会导致我们不期望看到的几何形变，而且由于速度瓶颈的存在，不可能采用多尺度或者是大量的数据增强去训练模型。 【流程】 首先通过selective search产生一系列的region proposal 然后训练多尺寸识别网络用以提取区域特征，其中处理方法是每个尺寸的最短边大小在尺寸集合中：$s \in S = {480,576,688,864,1200}$训练的时候通过上面提到的多尺寸训练方法，也就是在每个epoch中首先训练一个尺寸产生一个model，然后加载这个model并训练第二个尺寸，直到训练完所有的尺寸。空间金字塔池化使用的尺度为：1*1，2*2，3*3，6*6，一共是50个bins。 在测试时，每个region proposal选择能使其包含的像素个数最接近224*224的尺寸，提取相 应特征。 训练SVM，BoundingBox回归. 13/06/2018FAST R-CNNPaper: Fast R-CNN 【论文主要特点】（相对传统方法的改进） 测试时速度慢：RCNN一张图像内候选框之间大量重叠，提取特征操作冗余。本文将整张图像归一化后直接送入深度网络。在邻接时，才加入候选框信息，在末尾的少数几层处理每个候选框。 训练时速度慢 ：原因同上。在训练时，本文先一张图像送入网络，紧接着送入从这幅图像上提取出的候选区域。这些候选区域的前几层特征不需要再重复计算。 训练所需空间大: RCNN中独立的分类器和回归器需要大量特征作为训练样本。本文把类别判断和位置精调统一用深度网络实现，不再需要额外存储。 【流程】 网络首先用几个卷积层（conv）和最大池化层处理整个图像以产生conv特征图。 然后，对于每个对象建议框（object proposals ），感兴趣区域（region of interest——RoI）池层从特征图提取固定长度的特征向量。 每个特征向量被输送到分支成两个同级输出层的全连接（fc）层序列中：其中一层进行分类，对 目标关于K个对象类（包括全部“背景background”类）产生softmax概率估计，即输出每一个RoI的概率分布；另一层进行bbox regression，输出K个对象类中每一个类的四个实数值。每4个值编码K个类中的每个类的精确边界盒（bounding-box）位置，即输出每一个种类的的边界盒回归偏差。整个结构是使用多任务损失的端到端训练（trained end-to-end with a multi-task loss）。 14~15/06/2018FASTER R-CNNI want to use Faster R-cnn as the first method to implement object detection system. Paper: Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks JulyAugustSeptember]]></content>
      <categories>
        <category>Msc Project</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Object Detection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四月は君の嘘]]></title>
    <url>%2F2018%2F04%2F30%2FApri%2F</url>
    <content type="text"><![CDATA[YouTube Source【四月是你的謊言AMV】你還會記得嗎？四月は君の嘘 Your Lie in April BiliBili Source【四月是你的谎言】你还会记得吗 4月的最后一天了呢与你相遇的四月就要来了「君と出会った四月が来ているから」没有你的四月就要来了「君のいない四月は来ないで」]]></content>
      <categories>
        <category>My Life</category>
      </categories>
      <tags>
        <tag>友人A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Using Machine Learning in NBA]]></title>
    <url>%2F2018%2F01%2F31%2FMachine%20Learning%20in%20NBA%2F</url>
    <content type="text"><![CDATA[Fan-map plotting Obtain the game data in 2000~2017 in NBA Obtain the follwers of 2015~2017 NBA rookies by twittR package Obtain location information and plot the fan-map by Tableau Machine learning applyall-star players in 2017 prediction PCA 主成份分析 in all-star player prediction Keras是一个高层神经网络API，Keras由纯Python编写而成并基Tensorflow后端 All-star players in 2017 prediction Tensorboard is used to compare and choose better model. Best rookies in 2017 prediction PCA 主成份分析 in best rookies prediction Keras是一个高层神经网络API，Keras由纯Python编写而成并基Tensorflow后端 Best rookies in 2017 prediction First and Second rookies in 2017 prediction Muti-classes classification application Tensorboard is used to compare and choose better model. Potential all-star players in 2015~16 prediction PCA 主成份分析 in potential rookies prediction Keras是一个高层神经网络API，Keras由纯Python编写而成并基Tensorflow后端 Potential rookies in 2015~16 prediction Tensorboard is used to compare and choose better model. ResultWebsite: 2017 NBA ALL-STAR AND BEST ROOKIES PREDICTION WITH FAN-MAPexample: Neural network model 2D PCA (linear unseparable) Tensorboard check]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>NBA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MXnet 配置]]></title>
    <url>%2F2018%2F01%2F28%2FMXnet_Config%2F</url>
    <content type="text"><![CDATA[MXnet GPU version configuration (Windows 10. GTX960M)Tools Microsoft Visual Studio 2015 CUDA 9.0 cuDNN7 CMake OpenCV3.0 OpenBLAS Anaconda Graphviz Methods Step 1: Install VS2015 Step 2: Install CUDA 9.0 Step 3: Install cuDNN7 解压后把cudnn目录下的bin目录加到PATH环境变量里 Step 4: Install Opencv 下载并解压，然后创建环境变量OpenCV_DIR，把opencv/build目录添加进去,把\opencv\build\x64\vc12\bin和\opencv\build\x86\vc12\bin添加到PATH路径 Step 5: Install openBLAS 需要下载mingw64_dll.zip和OpenBLAS-v0.2.14-Win64-int64.zip两个文件. 创建环境变量 OpenBLAS_HOME，把openBLAS根目录加进去,把DLL所在目录需要添加到环境变量path中. 创建 “C:\Program files (x86)\OpenBLAS\” 复制相关文件进去 Step 6: Install Anaconda 把安装路径添加到PATH里去 Step 7: Install MXnet 创建MXnet 文件夹 然后使用命令行CD至该文件夹 1git clone --recursive https://github.com/dmlc/mxnet 在根目录创建build文件夹 (补充操作 目前未使用： 打开make文件夹的config.mk 文件 修改USE_CUDNN = 0 to USE_CUDNN = 1, 修改USE_BLAS = openBLAS ) Step 8: Install Cmake Configure and Genreate VS工程 mxnet.sln Configure的配置选择如下图 Step 9: 使用VS2015 打开mxnet.sln 切换成release模式 64位 然后启动编译 编译完成后，在mxnet_build\Release目录下生成了libmxnet.dll文件 Step 10: Install graphviz library 添加安装路径到环境变量path Step 11: 使用Anaconda的命令行 新建一个虚拟环境 1conda create --name MXNet python=2.7 MXNET目前不太适配python3, 激活环境 1activate MXNet Step 12: cd 至mxnet文件夹的python文件夹里， 拷贝如图的各个文件到该文件夹 然后使用 1python setup.py install Step 13: 再次拷贝上图的文件到Anaconda的MXNet虚拟环境的 Lib\site-packages\mxnet-版本名.egg\mxnet 中 并且添加此路径到环境变量path中 Step 14: 1conda install nb_conda 激活这个虚拟环境到juptyer notebook里面 打开jupyter book就可以进行测试了]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>MXnet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IT salary in USA]]></title>
    <url>%2F2018%2F01%2F28%2FIT%20salary%20in%20USA%2F</url>
    <content type="text"><![CDATA[ResultChart with Anlysis Website: SALARY DISTRIBUTION OF DIFFERENT JOBS IN USA Data processDatasets used to anlysis U.S. Technology Jobs on Dice.com Found in Kaggle US jobs on Monster.com Found in KaggleData Clean Obtain salay and coresspoding states information in US jos on Monster.com clean process Obtain salay and coresspoding cities information in US jos on Monster.com clean process Obtain skills information in U.S Technology Jobs on Dice.com clean process Chart PlottingChart 1: Map chart of average salay of 3 types jobsTableau address Chart 2: Bubble chart of average salay of 3 types jobsTableau address Chart 3 : Cloud words chart of skills used in IT-jobsCloud words tool]]></content>
      <categories>
        <category>Data Visualisation</category>
      </categories>
      <tags>
        <tag>data analysis</tag>
      </tags>
  </entry>
</search>
